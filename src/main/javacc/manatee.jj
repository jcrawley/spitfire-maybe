/*
 *  manatee.jj
 *
 *  A JavaCC specification for a subset of Manatee.
 */

options {
    UNICODE_INPUT = true;
    STATIC = false;
}

PARSER_BEGIN(Parser)

package edu.lmu.cs.xlg.manatee.syntax;

import java.util.List;
import java.util.ArrayList;
import java.io.Reader;
import edu.lmu.cs.xlg.util.Log;
import edu.lmu.cs.xlg.manatee.entities.*;

public class Parser {

    /**
     * Returns the result of parsing the Manatee program on the given Reader.
     */
    public Script parse(Log log) {
        try {
            return SCRIPT();
        } catch (TokenMgrError e) {
            log.exception(e);
            return null;
        } catch (ParseException e) {
            log.exception(e);
            return null;
        }
    }
}

PARSER_END(Parser)

SKIP: {
    " " | "\t" | <"--" (~["\n","\r"])*>
}

// Reserved Words and symbols

TOKEN: {
    "I" | "EI" | "E" | "DF" | "DC" | "L" | "R" | "B"
    | "N" | "S" | "C" | "Y" | "< >" | "T" | "F" | "P" | "LU" | "LF"
    | "LW"
    | ":" | "," | "+" | "-" | "*" | "/" | "==" | "^"
    | "<" | "<=" | "=" | ">=" | ">" | "(" | ")" | "[" | "]"
|
    < BR: "\n" | "\r" | "\r\n" >
|
    < INTLIT: (["0"-"9"])+ >
|
    < NUMLIT: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? >
|
    < #EXPONENT: ("x"|"") "10^" ("-")? (["0"-"9"])+ >
|
    < CHARLIT:
        "'"
        (
            ~["'", "\\" ,"\u0000"-"\u001f", "\u007f"-"\u009f"]
        |
            "\\" ["n", "t", "\"", "\'", "\\"]
        )
        "'"
    >
|
    < STRLIT:
        "\""
        (
            ~["\"", "\\" ,"\u0000"-"\u001f", "\u007f"-"\u009f"]
        |
            "\\" ["n", "t", "\"", "\'", "\\"]
        )*
        "\""
    >
|
    < ID: <LETTER> (<LETTER>|<DIGIT>|"_")* >
| 
    < #LETTER: [
    "\u0061"-"\u007a"
    ] >
|
    < #DIGIT: [
    "\u0030"-"\u0039", "\u0660"-"\u0669", "\u06f0"-"\u06f9", "\u0966"-"\u096f", "\u09e6"-"\u09ef",
    "\u0a66"-"\u0a6f", "\u0ae6"-"\u0aef", "\u0b66"-"\u0b6f", "\u0be7"-"\u0bef", "\u0c66"-"\u0c6f",
    "\u0ce6"-"\u0cef", "\u0d66"-"\u0d6f", "\u0e50"-"\u0e59", "\u0ed0"-"\u0ed9", "\u0f20"-"\u0f29",
    "\u1040"-"\u1049", "\u1369"-"\u1371", "\u17e0"-"\u17e9", "\u1810"-"\u1819", "\u1946"-"\u194f",
    "\uff10"-"\uff19"
    ] >
}

// -------------------
// SCRIPT -> BR* STMT+
// -------------------

Script SCRIPT(): {
    List<Statement> statements = new ArrayList<Statement>();
    Statement s;
}{
    (<BR>)*
    (s = STMT() {statements.add(s);})+
    <EOF>
    {return new Script(statements);}
}

// ---------------------------------------------------------------------
// STMT -> (DEC | ASSIGNMENT | PRINTSTMT | CONDITIONAL | LOOP | EXP) BR+
// ---------------------------------------------------------------------

Statement STMT(): {
    Statement s;
    ModifiedStatement.Modifier m = null;
}{
    (
        s = DEC()
    |
        s = ASSIGNMENT()
    |
        s = PRINTSTMT() 
    |
        s = CONDITIONAL() 
    |
        s = LOOP() 
    |
        s = EXP()
 
    )
    ((<BR>)+ | <EOF>)
    {return s;}
}

// ---------------------------------
// DEC -> VARDEC | FUNCDEC
// ---------------------------------

Statement DEC(): {
    Statement s;
}{
    (
        s = VARDEC()
    |
        s = FUNDEC()
    )
    {return s;}
}

// --------------------------------
// VARDEC -> my ID is always? EXP
//        |  my ID is (a | an) TYPE
// --------------------------------

Variable VARDEC(): {
    String t = null;
    Token v = null;
    Expression e = null;
    boolean constant = false;
}{
    v = <ID>
    (
        ("_" {constant = true;})? e = EXP()
    |
         (t = TYPE())
    )
    {return new Variable(v.image, t, e, constant);}
}

// ---------------------
// TYPE -> truth value
//     |  character
//     |  whole? number
//     |  string
//     |  TYPE list
// ---------------------

String TYPE(): {
    String t;
    StringBuilder builder = new StringBuilder();
}{
    (
        "B" {t = "boolean";}
    |
        "C" {t = "character";}
    |
        "S" {t = "String";}
    |
        "Y" {t = "any";}
    |
        "N" {t = "number";}
    |
  		ID()  		{  		  t = ID();
  		}
 |
 		"< >" 		{ 		  t = "null" 		}|
		"[" TYPE() "]"		{		  t = "array"
		}
    )
    {builder.append(t);}
    (
        LOOKAHEAD(2) "list" {builder.append(" list");}
    )*
    {return builder.toString();}
}

// ----------------------------------
// PROCDEC -> to ID PARAMS? BLOCK end
// ----------------------------------
/*
Procedure PROCDEC(): {
    Token name;
    List<Variable> params = new ArrayList<Variable>();
    Block body;
}{
    "to" name = <ID> (PARAMS(params))? body = BLOCK() "end"
    {return new Procedure(name.image, params, body);}
}
*/

// ----------------------------------------------------------------------
// FUNDEC -> to get (a | an | some | the)? TYPE ID (of PARAMS)? BLOCK end
// ----------------------------------------------------------------------

Function FUNDEC(): {
    String type;
    Token name;
    List<Variable> params = new ArrayList<Variable>();
    Block body;

}{
    "DF"
    name = <ID>
    (ARGS())?
    body = BLOCK()
    "end"
    {return new Function(type, name.image, params, body);}
}

// ----------------------------------------------------
// PARAMS -> TYPE ID (',' TYPE ID)* (','? and TYPE ID)?
// ----------------------------------------------------

void PARAMS(List<Variable> params): {
    String t;
    Token p;
}{
    t = TYPE() p = <ID>
    {params.add(new Variable(p.image, t, null, false));}
    (
        LOOKAHEAD(2) "," t = TYPE() p = <ID>
        {params.add(new Variable(p.image, t, null, false));}
    )*
    (
        (",")? "and" t = TYPE() p = <ID>
        {params.add(new Variable(p.image, t, null, false));}
    )?
}

// ----------------------
// BLOCK -> ":" BR+ STMT+
// ----------------------

Block BLOCK(): {
    List<Statement> statements = new ArrayList<Statement>();
    Statement s;
}{
    ":" (<BR>)+ ( s = STMT() {statements.add(s);} )+
    {return new Block(statements);}
}

// ----------------------------
// SIMPLESTMT -> write EXP
//            |  read EXP
//            |  set EXP to EXP
//            |  exit the loop
//            |  return EXP?
//            |  do nothing
//            |  do ID EXPLIST?
// ----------------------------

Statement SIMPLESTMT(): {
    Expression e = null;
    Token t = null;
    Expression source;
    Expression target;
    List<Expression> args = new ArrayList<Expression>();
}{
    (
        "write" e = EXP()
        {return new WriteStatement(e);}
    |
        "read" e = EXP()
        {return new ReadStatement(e);}
    |
        "set" target = EXP() "to" source = EXP()
        {return new AssignmentStatement(target, source);}
    |
        "exit" "the" "loop"
        {return new ExitStatement();}
    |
        "return" (e = EXP())?
        {return new ReturnStatement(e);}
    |
        LOOKAHEAD(2) "do" "nothing"
        {return new DoNothingStatement();}
    |
        "do" t = <ID> (args = EXPLIST())?
        {return new CallStatement(t.image, args);}
    )
}

// ----------------------------
// MODIFIER -> (if | while) EXP
// ----------------------------

ModifiedStatement.Modifier MODIFIER(): {
    ModifiedStatement.ModifierType m;
    Expression e;
}{
    (
        "if" {m = ModifiedStatement.ModifierType.IF;}
    |
        "while" {m = ModifiedStatement.ModifierType.WHILE;}
    )
    e = EXP()
    {return new ModifiedStatement.Modifier(m, e);}
}

// --------------------------
// COMPLEXSTMT -> CONDITIONAL
//             |  LOOP
// --------------------------

Statement COMPLEXSTMT(): {
    Statement s;
}{
    (
        s = CONDITIONAL()
    |
        s = LOOP()
    )
    {return s;}
}
// ------------------------------------------------------------------
// CONDITIONAL -> if EXP BLOCK (else if EXP BLOCK)* (else BLOCK)? end
// ------------------------------------------------------------------

Statement CONDITIONAL(): {
    ConditionalStatement.Arm arm;
    List<ConditionalStatement.Arm> arms = new ArrayList<ConditionalStatement.Arm>();
    Expression e;
    Block b;
    Block elseBlock = null;
}{
    "if" e = EXP() b = BLOCK()
    {arms.add(new ConditionalStatement.Arm(e, b));}
    (
        LOOKAHEAD(2) "else" "if" e = EXP() b = BLOCK()
        {arms.add(new ConditionalStatement.Arm(e, b));}
    )*
    (
        "else" elseBlock = BLOCK()
    )?
    "end"
    {return new ConditionalStatement(arms, elseBlock);}
}

// -----------------------------------------------------
// LOOP        -> LOOPCONTROL BLOCK end
// LOOPCONTROL -> loop (EXP times)?
//             |  while EXP
//             |  for each ID in EXP (to EXP (by EXP)?)?
// -----------------------------------------------------

Statement LOOP(): {
    Token t = null;
    Expression e = null;
    Expression e2 = null;
    Expression e3 = null;
    Block b;
}{
    (
        "loop" (e = EXP() "times")? b = BLOCK() "end"
        {return e == null ? new PlainLoop(b) : new TimesLoop(e, b);}
    |
        "while" e = EXP() b = BLOCK() "end"
        {return new WhileLoop(e, b);}
    |
        "for" "each" t = <ID> "in" e = EXP()
        (
            "to" e2 = EXP() ("by" e3 = EXP())?
        )?
        b = BLOCK() "end"
        {
            if (e2 == null) {
                return new CollectionLoop(t.image, e, b);
            } else {
                return new RangeLoop(t.image, e, e2, e3, b);
            }
        }
    )
}

// ----------------------
// EXP -> EXP1 (or EXP1)*
// ----------------------

Expression EXP(): {
    Expression e1;
    Expression e2;
}{
    e1 = EXP1()
    ("or" e2 = EXP1() {e1 = new BinaryExpression(e1, "or", e2);})*
    {return e1;}
}

// ------------------------
// EXP1 -> EXP2 (and EXP2)*
// ------------------------

Expression EXP1(): {
    Expression e1;
    Expression e2;
}{
    e1 = EXP5()
    ("and" e2 = EXP5() {e1 = new BinaryExpression(e1, "and", e2);})*
    {return e1;}
}

// --------------------------
// EXP5 -> EXP6 (RELOP EXP6)?
// --------------------------

Expression EXP5(): {
    String op;
    Expression e1;
    Expression e2;
}{
    e1 = EXP6()
    (
        op = RELOP()
        e2 = EXP6()
        {e1 = new BinaryExpression(e1, op, e2);}
    )?
    {return e1;}
}

// ----------------------------
// EXP6 -> EXP7 (SHIFTOP EXP7)*
// ----------------------------

Expression EXP6(): {
    String op;
    Expression e1;
    Expression e2;
}{
    e1 = EXP7()
    (
        op = SHIFTOP()
        e2 = EXP7()
        {e1 = new BinaryExpression(e1, op, e2);}
    )*
    {return e1;}
}

// --------------------------
// EXP7 -> EXP8 (ADDOP EXP8)*
// --------------------------

Expression EXP7(): {
    String op;
    Expression e1;
    Expression e2;
}{
    e1 = EXP8()
    (
        op = ADDOP()
        e2 = EXP8()
        {e1 = new BinaryExpression(e1, op, e2);}
    )*
    {return e1;}
}
// --------------------------
// EXP8 -> EXP9 (MULOP EXP9)*
// --------------------------

Expression EXP8(): {
    String op;
    Expression e1;
    Expression e2;
}{
    e1 = EXP9()
    (
        op = MULOP()
        e2 = EXP9()
        {e1 = new BinaryExpression(e1, op, e2);}
    )*
    {return e1;}
}

// ---------------------
// EXP9 -> PREFIX* EXP10
// ---------------------

Expression EXP9(): {
    String op = null;
    Expression e;
}{
    (op = PREFIX())? e = EXP10()
    {return op == null ? e : new UnaryExpression(op, e);}
}

// ----------------------------------------
// EXP10 -> EXP11 SUFFIX*
// SUFFIX -> '(' EXPLIST? ')' | '[' EXP ']'
// ----------------------------------------

Expression EXP10(): {
    Expression e;
    List<Expression> args = new ArrayList<Expression>();
    Expression subscript;
}{
    e = EXP11()
    (
        "(" (args = EXPLIST())? ")"
        {e = new FunctionCall(e, args);}
    |
        "[" subscript = EXP() "]"
        {e = new SubscriptExpression(e, subscript);}
    )*
    {return e;}
}

// -------------------------
// EXP11 -> LITERAL
//       |  ID
//       |  '[' EXPLIST? ']'
//       |  '(' EXP ')'
// -------------------------

Expression EXP11(): {
    List<Expression> expressions = new ArrayList<Expression>();
    Expression e = null;
    Token t;
}{
    (
        e = LITERAL()
        {return e;}
    |
        t = <ID>
        {return new IdentifierExpression(t.image);}
    |
        "[" (expressions = EXPLIST())? "]"
        {return new ArrayConstructor(expressions);}
    |
        "(" e = EXP() ")"
        {return e;}
    )
}

// ------------------
// LITERAL -> nothing
//         |  yes
//         |  no
//         |  INTLIT
//         |  NUMLIT
//         |  CHARLIT
//         |  STRLIT
// ------------------

Literal LITERAL(): {
    Token t;
}{
    "nothing" {return NullLiteral.INSTANCE;}
|
    "yes" {return BooleanLiteral.TRUE;}
|
    "no" {return BooleanLiteral.FALSE;}
|
    t = <INTLIT> {return new WholeNumberLiteral(t.image);}
|
    t = <NUMLIT> {return new NumberLiteral(t.image);}
|
    t = <CHARLIT> {return new CharacterLiteral(t.image);}
|
    t = <STRLIT> {return new StringLiteral(t.image);}
}

// -------------------------
// EXPLIST -> EXP (',' EXP)*
// -------------------------

List<Expression> EXPLIST(): {
    List<Expression> expressions = new ArrayList<Expression>();
    Expression e;
}{
    e = EXP() {expressions.add(e);}
    ("," e = EXP() {expressions.add(e);})*
    {return expressions;}
}

// ------------------------------------------------------
// RELOP -> '<' | '<=' | '=' | '≠' | '>=' | '>' | is not?
// ------------------------------------------------------

String RELOP(): {
}{
    "<" {return "<";}
    |
    "<=" {return "<=";}
    |
    "=" {return "=";}
    |
    "≠" {return "≠";}
    |
    ">=" {return ">=";}
    |
    ">" {return ">";}
    |
    LOOKAHEAD(2) "is" "not" {return "is not";}
    |
    "is" {return "is";}
}

// ----------------------
// SHIFTOP -> '<<' | '>>'
// ----------------------

String SHIFTOP(): {
    Token t;
}{
    (t = "<<" | t = ">>")
    {return t.image;}
}

// -----------------------
// ADDOP -> '+' | '-' | in
// -----------------------

String ADDOP(): {
    Token t;
}{
    (t = "+" | t = "-" | t = "in")
    {return t.image;}
}

// ------------------
// MULOP -> '*' | '/'
// ------------------

String MULOP(): {
    Token t;
}{
    (t = "*" | t = "/")
    {return t.image;}
}

// -------------------------------
// PREFIX -> '-' | not | length of
// -------------------------------

String PREFIXOP(): {
    Token t;
}{
    (t = "-" | t = "not" | t = "length" "of")
    {return t.image;}
}
